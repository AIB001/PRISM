# PRISM 分析模块方法说明文档

本文档详细描述 PRISM 分析模块中各种分析方法的计算原理、参数设置和可视化输出。

---

## 目录

1. [结构分析](#1-结构分析)
   - [RMSD (均方根偏差)](#11-rmsd-均方根偏差)
   - [RMSF (均方根涨落)](#12-rmsf-均方根涨落)
2. [接触分析](#2-接触分析)
   - [接触距离定义](#21-接触距离定义)
   - [接触频率分析](#22-接触频率分析)
   - [接触数目时间序列](#23-接触数目时间序列)
   - [残基间距离分析](#24-残基间距离分析)
3. [聚类分析](#3-聚类分析)
   - [K-means 聚类](#31-k-means-聚类)
   - [DBSCAN 聚类](#32-dbscan-聚类)
   - [层次聚类](#33-层次聚类)
4. [氢键分析](#4-氢键分析)
5. [二面角分析](#5-二面角分析)
6. [可视化图表说明](#6-可视化图表说明)

---

## 1. 结构分析

### 1.1 RMSD (均方根偏差)

**计算原理：**

RMSD (Root Mean Square Deviation) 用于衡量结构相对于参考结构的偏离程度。计算公式为：

$$
\text{RMSD} = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (r_i - r_{0i})^2}
$$

其中：
- $N$ 是原子数目
- $r_i$ 是第 i 个原子在当前帧的坐标
- $r_{0i}$ 是第 i 个原子在参考结构中的坐标

**关键参数：**
- **对齐选择** (`align_selection`): 用于叠合的原子选择，通常是蛋白质的 Cα 原子 (`"protein and name CA"`)
- **计算选择** (`calculate_selection`): 实际计算 RMSD 的原子选择，可以与对齐选择不同
- **参考帧** (`ref_frame`): 参考结构的帧索引，默认为 0（第一帧）
- **步长** (`step`): 分析的帧间隔，用于加速计算

**计算流程：**
1. 选择参考结构（通常是第一帧或实验结构）
2. 根据 `align_selection` 将轨迹叠合到参考结构
3. 对 `calculate_selection` 指定的原子计算 RMSD
4. 输出每帧的 RMSD 值（单位：Å）

**典型用法：**
```python
# 蛋白质骨架 RMSD（对齐和计算都用 Cα）
rmsd = analyzer.calculate_rmsd(
    universe=topology_file,
    trajectory=trajectory_file,
    align_selection="protein and name CA",
    calculate_selection="protein and name CA"
)

# 配体 RMSD（在蛋白质对齐后计算配体偏移）
rmsd_ligand = analyzer.calculate_rmsd(
    universe=topology_file,
    trajectory=trajectory_file,
    align_selection="protein and name CA",  # 先对齐蛋白质
    calculate_selection="resname LIG"       # 再计算配体 RMSD
)
```

**输出图表：**
- **RMSD 时间序列图**：展示 RMSD 随时间的变化
  - X 轴：时间 (ns)
  - Y 轴：RMSD (Å)
  - 可包含平滑曲线（Savitzky-Golay 滤波）

### 1.2 RMSF (均方根涨落)

**计算原理：**

RMSF (Root Mean Square Fluctuation) 用于衡量每个原子/残基在轨迹中的涨落程度。计算公式为：

$$
\text{RMSF}_i = \sqrt{\frac{1}{T} \sum_{t=1}^{T} (r_i(t) - \bar{r}_i)^2}
$$

其中：
- $T$ 是总帧数
- $r_i(t)$ 是第 i 个原子在时间 t 的坐标
- $\bar{r}_i$ 是第 i 个原子在整个轨迹中的平均坐标

**关键参数：**
- **对齐选择** (`align_selection`): 用于叠合的原子，确保计算前结构已对齐
- **计算选择** (`calculate_selection`): 实际计算 RMSF 的原子
- **自动链检测** (`auto_detect_chains`): 是否自动检测所有蛋白质链和核酸链

**计算流程：**
1. 将轨迹叠合到平均结构（自动计算）
2. 计算每个原子的均方根涨落
3. 对于 Cα/P 原子，每个残基/核苷酸对应一个 RMSF 值
4. 输出 RMSF 值和对应的残基/核苷酸编号

**自动链检测：**
- **蛋白质链**：使用 Cα 原子
- **核酸链**：使用 P 原子（磷酸骨架）
- 自动为每条链生成独立的 RMSF 数据

**输出图表：**
- **RMSF vs 残基编号图**：展示每个残基的涨落程度
  - X 轴：残基编号
  - Y 轴：RMSF (Å)
  - 不同链使用不同颜色/面板展示

---

## 2. 接触分析

### 2.1 接触距离定义

**距离计算方法：**

PRISM 中的接触分析基于**原子对距离**，而非质心距离。具体方法：

1. **重原子选择**：
   - 配体：所有非氢原子
   - 蛋白质残基：骨架和侧链的 C、N、O、S 原子

2. **距离计算**：
   - 对于每对原子 (配体原子, 蛋白质原子)，计算空间距离
   - 使用 MDTraj 的 `compute_distances()` 函数
   - **最近距离**：对于某个残基，取配体与该残基所有原子的最小距离

3. **接触判定**：
   - 使用阈值 `contact_enter_threshold_nm`（默认 0.45 nm = 4.5 Å）
   - 如果原子对距离 < 阈值，则记为接触

**关键说明：**
- **不是质心距离**：计算的是实际原子间的最近距离
- **不是最小距离的平均**：而是对所有原子对独立判断接触

### 2.2 接触频率分析

**计算方法：**

1. **原子对接触频率** (`contact_frequencies`)：
   - 对于每对 (配体原子, 残基)，统计在所有帧中形成接触的比例
   - 公式：

   $$
   \text{频率} = \frac{\text{接触帧数}}{\text{总帧数}}
   $$

2. **残基接触比例** (`residue_proportions`)：
   - 对于每个残基，考虑与其形成接触的配体原子数量
   - 公式：

   $$
   \text{比例} = \frac{\text{总接触数}}{\text{总帧数} \times \text{接触的配体原子数}}
   $$

   - 这个指标归一化了残基大小的影响

3. **平均接触距离** (`residue_avg_distances`)：
   - 对于每个残基，计算所有接触原子对在接触状态下的平均距离
   - 只统计距离 < 阈值的帧

**输出数据：**
```python
result = {
    'contact_frequencies': {(ligand_atom_index, 'RES123'): 0.85, ...},  # 原子-残基接触频率
    'residue_proportions': {'RES123': 0.75, 'RES456': 0.60, ...},       # 残基接触比例
    'residue_avg_distances': {'RES123': 3.2, 'RES456': 3.8, ...},       # 平均接触距离 (Å)
    'residue_best_ligand_atoms': {'RES123': 5, ...},                    # 每个残基接触最多的配体原子
}
```

**可视化：**
- **接触频率条形图**：展示关键残基的接触比例
- **接触热图**：配体原子 vs 残基的接触矩阵
- **交互式 HTML**：3D 可视化接触网络

### 2.3 接触数目时间序列

**计算方法：**

统计每一帧中形成接触的原子对数量。

**实现步骤：**
1. 对所有配体-蛋白质原子对计算距离矩阵
2. 对每一帧，统计距离 < 阈值的原子对数量
3. 输出时间序列数据

**输出数据：**
```python
results = {
    'contact_numbers': np.array([45, 48, 52, ...]),  # 每帧的接触数
    'times': np.array([0, 0.5, 1.0, ...]),           # 时间点 (ns)
    'total_pairs': 12500                              # 总原子对数
}
```

**可视化：**
- **接触数目时间序列图**：
  - X 轴：时间 (ns)
  - Y 轴：接触原子对数量
  - 可显示移动平均线

### 2.4 残基间距离分析

**两种距离分析方法：**

#### 方法 1: 接触距离分布 (`analyze_contact_distances`)

- **目的**：分析形成接触时的距离分布
- **方法**：
  - 对于每个关键残基，计算与配体的最小距离（每帧一个值）
  - 无距离过滤（包含所有帧，即使未形成接触）
  - 适用于研究动态接触/非接触转换

#### 方法 2: 距离时间序列 (`analyze_residue_distance_timeseries`)

- **目的**：追踪特定残基与配体的距离随时间变化
- **方法**：
  - 每帧取残基-配体原子对的最小距离
  - 输出完整时间序列

**输出数据：**
```python
# 接触距离分布
distances = {
    'ASP618': np.array([3.2, 3.5, 3.1, ...]),  # 距离数组 (Å)
    'ARG555': np.array([3.8, 4.2, 3.9, ...])
}

# 距离时间序列
timeseries = {
    'ASP618': np.array([3.2, 3.5, 3.1, ...]),  # 距离时间序列 (Å)
    'ARG555': np.array([3.8, 4.2, 3.9, ...]),
    'times': np.array([0, 0.5, 1.0, ...])       # 时间点 (ns)
}
```

**可视化：**
- **距离分布直方图**：展示距离的概率分布
- **距离时间序列图**：展示距离随时间的演化
- **距离箱线图**：比较多个残基的距离分布

---

## 3. 聚类分析

聚类分析用于识别轨迹中结构相似的构象群（状态）。PRISM 支持三种主要聚类方法。

### 3.1 K-means 聚类

**方法原理：**

K-means 是基于距离的聚类方法，将构象划分为 k 个簇，使簇内方差最小化。

**算法步骤：**
1. **坐标提取**：提取用于聚类的原子坐标（通常是 Cα 或蛋白质骨架）
2. **标准化**：对坐标进行标准化（零均值、单位方差）
3. **降维（可选）**：使用 PCA 降低维度（推荐）
4. **聚类**：使用 K-means 算法将帧分配到 k 个簇
5. **质心计算**：每个簇的中心点（代表结构）

**关键参数：**
- **`n_clusters`**: 簇的数量（需要预先指定）
- **`use_pca`**: 是否使用 PCA 降维（推荐 True）
- **`n_components`**: PCA 主成分数量（默认 10）
- **`align_selection`**: 对齐原子（通常是 Cα）
- **`cluster_selection`**: 用于聚类的原子（可以是全蛋白或 Cα）

**评估指标：**
- **轮廓系数** (Silhouette Score)：范围 [-1, 1]，越接近 1 表示聚类越好
- **惯性** (Inertia)：簇内距离平方和，越小越好

**输出数据：**
```python
results = {
    'labels': np.array([0, 1, 1, 0, 2, ...]),        # 每帧的簇标签
    'cluster_centers': np.array([[...], [...]]),     # 簇中心坐标
    'silhouette_score': 0.65,                        # 轮廓系数
    'n_clusters': 5,                                 # 簇数量
    'inertia': 1234.5                                # 惯性
}
```

**可视化：**
- **PCA 投影散点图**：在前两个主成分空间展示聚类结果
- **聚类时间序列**：显示每帧属于哪个簇（状态转换图）
- **簇大小饼图**：展示每个簇包含的帧数比例
- **代表结构**：保存每个簇的质心结构（PDB 文件）

### 3.2 DBSCAN 聚类

**方法原理：**

DBSCAN (Density-Based Spatial Clustering of Applications with Noise) 是基于密度的聚类方法，能够：
- 自动确定簇的数量
- 识别噪声点（离群帧）
- 发现任意形状的簇

**算法步骤：**
1. 定义邻域：以 `eps` 为半径
2. 核心点：邻域内至少有 `min_samples` 个点
3. 边界点：在核心点邻域内但本身不是核心点
4. 噪声点：既不是核心点也不是边界点

**关键参数：**
- **`eps`**: 邻域半径
  - 如果 `use_pca=True`，eps 是 PCA 空间中的距离（无量纲）
  - 如果 `use_pca=False`，eps 是 RMSD 距离（Å）
- **`min_samples`**: 核心点最少邻居数（通常 5-10）
- **`use_pca`**: 是否使用 PCA（推荐 True）

**参数选择建议：**
- **小的 eps**（如 0.3-0.5）：产生更多小簇
- **大的 eps**（如 1.0-2.0）：产生少量大簇
- **`min_samples`**: 约为 $\ln(N)$，其中 $N$ 是总帧数

**输出数据：**
```python
results = {
    'labels': np.array([0, 1, -1, 0, 2, ...]),   # -1 表示噪声点
    'n_clusters': 4,                              # 自动确定的簇数
    'n_noise': 15,                                # 噪声点数量
    'silhouette_score': 0.58                      # 轮廓系数（不包含噪声）
}
```

**可视化：**
- **DBSCAN 散点图**：噪声点用特殊颜色标记
- **簇统计条形图**：展示每个簇和噪声点的帧数

### 3.3 层次聚类

**方法原理：**

层次聚类（Agglomerative Clustering）构建一个层次树状结构：
- **凝聚式**：从每个点作为一个簇开始，逐步合并
- **可切割**：在任意层次切割树状图得到不同数量的簇

**算法步骤：**
1. 每个帧初始为一个簇
2. 迭代合并距离最近的两个簇
3. 在指定层次切割得到最终簇

**关键参数：**
- **`n_clusters`**: 最终簇的数量
- **`linkage`**: 簇间距离计算方法
  - `ward`: 最小化簇内方差（推荐）
  - `complete`: 最大距离
  - `average`: 平均距离

**可视化：**
- **树状图** (Dendrogram)：展示层次结构
- **热图**：展示帧间 RMSD 矩阵

### 3.4 最优簇数选择

PRISM 提供 `find_optimal_clusters()` 方法自动寻找最优簇数。

**评估指标：**
1. **轮廓系数**：衡量簇的紧密度和分离度
2. **肘部法则**（仅 K-means）：惯性随簇数的变化曲线

**使用方法：**
```python
results = analyzer.find_optimal_clusters(
    universe=topology_file,
    trajectory=trajectory_file,
    max_clusters=10,        # 测试 2-10 个簇
    method="kmeans"
)
optimal_k = results['optimal_clusters']  # 推荐的簇数
```

**可视化：**
- **轮廓系数曲线**：展示不同簇数的评分
- **肘部图**：惯性随簇数变化

---

## 4. 氢键分析

**计算原理：**

氢键通过几何标准判定：
- **距离标准**：供体重原子 - 受体重原子距离 $< 3.5$ Å
- **角度标准**：D-H···A 角度 $> 120°$

**分析内容：**
1. 识别配体-蛋白质氢键
2. 统计氢键形成频率
3. 追踪氢键随时间的变化

**输出数据：**
- 氢键对列表及其形成频率
- 氢键数目时间序列
- 关键残基的氢键统计

**可视化：**
- 氢键频率条形图
- 氢键网络图
- 氢键数目时间序列

---

## 5. 二面角分析

**分析类型：**

1. **主链二面角** ($\phi$, $\psi$)：
   - $\phi$ (phi)：C(-1) - N - Cα - C
   - $\psi$ (psi)：N - Cα - C - N(+1)
   - 用于 Ramachandran 图分析

2. **侧链二面角** ($\chi_1$, $\chi_2$, ...)：
   - $\chi_1$：N - Cα - Cβ - Cγ
   - $\chi_2$：Cα - Cβ - Cγ - Cδ
   - 用于分析侧链构象

**可视化：**
- **Ramachandran 图**：$\phi$-$\psi$ 分布
- **二面角时间序列**：追踪特定残基的构象变化
- **二面角分布直方图**：统计构象偏好

---

## 6. 可视化图表说明

### 6.1 图表通用规范

**字体与样式：**
- **字体**：Times New Roman（全局统一）
- **字体大小**：足够大以适合作为子图使用
- **分辨率**：300 DPI（出版级）
- **文件格式**：PNG（默认）、PDF（矢量图）

**文件命名规范：**
- 使用描述性名称，如 `protein_rmsd_timeseries.png`
- 避免通用名称，如 `plot.png`

### 6.2 主要图表类型

#### 时间序列图 (Timeseries Plots)
- **用途**：RMSD、接触数、氢键数随时间变化
- **特点**：可包含平滑曲线、移动平均

#### 残基分布图 (Per-Residue Plots)
- **用途**：RMSF、B-factor、接触频率 vs 残基编号
- **特点**：可标注关键残基、区域

#### 散点图 (Scatter Plots)
- **用途**：聚类分析的 PCA 投影
- **特点**：不同簇用不同颜色标记

#### 热图 (Heatmaps)
- **用途**：接触矩阵、RMSD 矩阵、距离矩阵
- **特点**：颜色映射、色标

#### 分布图 (Distribution Plots)
- **用途**：直方图、箱线图、小提琴图
- **特点**：展示数据分布特征

#### 条形图 (Bar Charts)
- **用途**：接触频率、簇大小、氢键统计
- **特点**：可按值排序、突出显示

#### 多面板组图 (Multi-Panel Figures)
- **用途**：综合展示多个相关分析结果
- **特点**：统一样式、共享坐标轴

### 6.3 交互式可视化

**HTML 输出：**
- 使用 Plotly 生成交互式图表
- 支持缩放、悬停信息、导出
- 适用于探索性分析

**3D 可视化：**
- 分子结构与分析数据叠加
- 接触网络 3D 展示

---

## 7. 性能优化

### 7.1 并行计算

**自动并行化：**
- PRISM 自动检测可用 CPU 核心
- 通过 OpenMP 并行化距离计算、RMSD 等操作
- 用户无需手动配置

**配置方法：**
```python
import os
os.environ['OMP_NUM_THREADS'] = '8'  # 手动指定线程数
```

### 7.2 缓存机制

**自动缓存：**
- 所有计算结果自动缓存到 `cache/` 目录
- 使用 pickle 序列化存储
- 缓存键基于参数和文件名自动生成

**缓存使用：**
```python
# 第一次运行：执行计算并缓存
rmsd = analyzer.calculate_rmsd(...)

# 第二次运行：从缓存加载（几乎即时）
rmsd = analyzer.calculate_rmsd(...)  # 相同参数
```

**清除缓存：**
```bash
rm -rf cache/  # 删除所有缓存
```

### 7.3 内存优化

**大型轨迹处理：**
- 使用 `step` 参数跳帧分析
- 限制 `start_frame` 和 `end_frame`
- 使用流式处理（自动）

---

## 8. 实用建议

### 8.1 参数选择

**RMSD/RMSF 分析：**
- 对齐选择：使用稳定区域（如 Cα）
- 计算选择：根据研究目标选择（配体、结合位点等）

**接触分析：**
- 阈值：4.0-4.5 Å 是常用范围
- 关键残基：可通过 `analyze_key_residue_contacts()` 自动筛选 Top N

**聚类分析：**
- K-means：先用 `find_optimal_clusters()` 确定簇数
- DBSCAN：从小的 `eps` 开始尝试，观察簇数和噪声点比例
- 使用 PCA 降维可显著加速计算

### 8.2 分析流程

**典型工作流：**
1. **预处理**：PBC 校正、轨迹对齐
2. **初步分析**：RMSD、RMSF 了解整体稳定性
3. **详细分析**：接触、氢键分析结合位点
4. **构象分析**：聚类识别主要状态
5. **可视化**：生成出版级图表

### 8.3 常见问题

**Q: RMSD 持续增加怎么办？**
- 检查是否需要更稳定的对齐选择
- 可能需要去除整体平移/旋转

**Q: 聚类结果不理想？**
- 尝试调整簇数或算法参数
- 检查 PCA 解释方差是否足够（建议 $> 80\%$）
- 可能需要更长的轨迹或更好的采样

**Q: 接触分析的阈值如何选择？**
- 4.0-4.5 Å 是常用范围（第一配位层）
- 可根据具体系统调整（大配体可适当增大）

---

## 9. 参考文献

**方法学参考：**
- RMSD/RMSF: Caves et al., 1998
- K-means clustering: MacQueen, 1967
- DBSCAN: Ester et al., 1996
- MDTraj: McGibbon et al., 2015

**PRISM 文档：**
- 完整 API 文档：`prism/analysis/README.md`
- 模块开发指南：`prism/analysis/CLAUDE.md`
- 示例脚本：`test/analysis/` 目录

---

**文档版本**: v1.0
**最后更新**: 2025-01-10
**维护者**: PRISM 开发团队
