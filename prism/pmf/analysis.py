#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PRISM PMF Analysis Module

Analyzes results from Steered MD (SMD) and umbrella sampling simulations:
- Parse GROMACS .xvg files (pullf, pullx, pmf, histogram)
- Compute rupture force, work, and binding free energy
- Validate umbrella sampling window overlap
- Generate publication-quality plots and analysis reports
"""

import os
import logging
import numpy as np
from pathlib import Path
from typing import Tuple, Optional, Dict, List

logger = logging.getLogger(__name__)


class PMFAnalyzer:
    """Analyze PMF results from SMD and umbrella sampling.

    Expected directory layout (generated by ``prism --pmf``)::

        pmf_dir/                        # GMX_PROLIG_PMF
        ├── smd/
        │   ├── pullf.xvg               # Pull force vs time
        │   └── pullx.xvg               # Pull position vs time
        ├── umbrella/
        │   ├── window_0/
        │   │   ├── umbrella.tpr
        │   │   ├── pullf.xvg
        │   │   └── pullx.xvg
        │   ├── ...
        │   ├── tpr-files.dat
        │   ├── pullf-files.dat
        │   ├── pmf.xvg                 # WHAM output
        │   ├── histo.xvg               # Window histograms
        │   └── bsprofile.xvg           # Bootstrap profiles
        ├── smd_run.sh
        └── umbrella_run.sh

    Parameters
    ----------
    pmf_dir : str
        Path to GMX_PROLIG_PMF directory.
    verbose : bool
        If True, log informational messages.
    """

    def __init__(self, pmf_dir: str, verbose: bool = True):
        self.pmf_dir = Path(pmf_dir)
        self.smd_dir = self.pmf_dir / "smd"
        self.umbrella_dir = self.pmf_dir / "umbrella"

        if verbose:
            logger.setLevel(logging.INFO)
        else:
            logger.setLevel(logging.WARNING)

        if not self.pmf_dir.exists():
            raise FileNotFoundError(f"PMF directory not found: {self.pmf_dir}")

    # ------------------------------------------------------------------
    # XVG parsing
    # ------------------------------------------------------------------

    @staticmethod
    def parse_xvg(filepath: str) -> Tuple[np.ndarray, ...]:
        """Parse a GROMACS .xvg file, skipping comment/header lines.

        Parameters
        ----------
        filepath : str
            Path to the .xvg file.

        Returns
        -------
        tuple of np.ndarray
            Column arrays from the file. For a typical 2-column file this
            returns ``(x, y)``; multi-column files return one array per column.

        Raises
        ------
        FileNotFoundError
            If *filepath* does not exist.
        ValueError
            If the file contains no numeric data.
        """
        filepath = Path(filepath)
        if not filepath.exists():
            raise FileNotFoundError(f"XVG file not found: {filepath}")

        rows: List[List[float]] = []
        with open(filepath, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith(("#", "@")):
                    continue
                try:
                    rows.append([float(v) for v in line.split()])
                except ValueError:
                    continue

        if not rows:
            raise ValueError(f"No numeric data found in {filepath}")

        data = np.array(rows)
        return tuple(data[:, i] for i in range(data.shape[1]))

    # ------------------------------------------------------------------
    # SMD analysis
    # ------------------------------------------------------------------

    def analyze_smd(self) -> Dict:
        """Parse pullf.xvg and pullx.xvg, compute rupture force and work.

        Returns
        -------
        dict
            ``rupture_force``   – maximum absolute pull force (kJ/mol/nm)
            ``rupture_time``    – time at rupture (ps)
            ``rupture_position``– COM distance at rupture (nm)
            ``work``            – cumulative work by trapezoidal integration (kJ/mol)
            ``force_time``      – time array from pullf
            ``force_values``    – force array from pullf
            ``position_time``   – time array from pullx
            ``position_values`` – position array from pullx

        Raises
        ------
        FileNotFoundError
            If pullf.xvg or pullx.xvg are missing.
        """
        pullf_path = self.smd_dir / "pullf.xvg"
        pullx_path = self.smd_dir / "pullx.xvg"

        force_time, force_values = self.parse_xvg(str(pullf_path))
        position_time, position_values = self.parse_xvg(str(pullx_path))

        # Rupture force: maximum |F|
        abs_force = np.abs(force_values)
        rupture_idx = int(np.argmax(abs_force))
        rupture_force = float(abs_force[rupture_idx])
        rupture_time = float(force_time[rupture_idx])

        # Corresponding position at rupture time (interpolate if grids differ)
        rupture_position = float(np.interp(rupture_time, position_time, position_values))

        # Work = integral F dx  (trapezoidal, using position as x-coordinate)
        # Align force and position on common time grid
        common_time = force_time  # force grid is typically finer or equal
        interp_pos = np.interp(common_time, position_time, position_values)
        work = float(np.trapz(force_values, interp_pos))

        logger.info(f"SMD rupture force: {rupture_force:.1f} kJ/mol/nm at t={rupture_time:.0f} ps")
        logger.info(f"SMD cumulative work: {work:.1f} kJ/mol")

        return {
            "rupture_force": rupture_force,
            "rupture_time": rupture_time,
            "rupture_position": rupture_position,
            "work": work,
            "force_time": force_time,
            "force_values": force_values,
            "position_time": position_time,
            "position_values": position_values,
        }

    # ------------------------------------------------------------------
    # Umbrella sampling validation
    # ------------------------------------------------------------------

    def validate_umbrella_windows(self) -> Dict:
        """Check umbrella window completeness and data integrity.

        Returns
        -------
        dict
            ``total_windows``     – number of window directories found
            ``completed_windows`` – windows with valid TPR + pullf files
            ``failed_windows``    – list of window names that are incomplete
            ``completion_rate``   – fraction of completed windows
            ``positions``         – nominal position of each valid window (nm)
        """
        if not self.umbrella_dir.exists():
            raise FileNotFoundError(f"Umbrella directory not found: {self.umbrella_dir}")

        window_dirs = sorted(self.umbrella_dir.glob("window_*"))
        if not window_dirs:
            return {
                "total_windows": 0,
                "completed_windows": 0,
                "failed_windows": [],
                "completion_rate": 0.0,
                "positions": [],
            }

        completed = []
        failed = []
        positions: List[float] = []

        for wdir in window_dirs:
            tpr = wdir / "umbrella.tpr"
            pullf = wdir / "pullf.xvg"

            if not tpr.exists() or not pullf.exists():
                failed.append(wdir.name)
                continue
            if tpr.stat().st_size == 0 or pullf.stat().st_size < 100:
                failed.append(wdir.name)
                continue

            completed.append(wdir.name)

            # Try to extract mean position from pullx or pullf
            pullx = wdir / "pullx.xvg"
            if pullx.exists():
                try:
                    _, pos = self.parse_xvg(str(pullx))
                    positions.append(float(np.mean(pos)))
                except (ValueError, IndexError):
                    pass

        total = len(window_dirs)
        n_completed = len(completed)
        rate = n_completed / total if total else 0.0

        logger.info(f"Umbrella windows: {n_completed}/{total} completed ({rate:.0%})")
        if failed:
            logger.warning(f"Failed windows: {', '.join(failed)}")

        return {
            "total_windows": total,
            "completed_windows": n_completed,
            "failed_windows": failed,
            "completion_rate": rate,
            "positions": sorted(positions),
        }

    def check_histogram_overlap(self, hist_file: Optional[str] = None) -> Dict:
        """Analyze histogram overlap between adjacent umbrella windows.

        Parameters
        ----------
        hist_file : str, optional
            Path to histo.xvg from ``gmx wham``.  Defaults to
            ``umbrella/histo.xvg``.

        Returns
        -------
        dict
            ``n_windows``      – number of histogram columns
            ``overlaps``       – list of overlap fractions between adjacent windows
            ``min_overlap``    – smallest adjacent overlap
            ``mean_overlap``   – mean adjacent overlap
            ``poorly_sampled`` – indices of window pairs with overlap < 10 %
        """
        if hist_file is None:
            hist_file = str(self.umbrella_dir / "histo.xvg")

        columns = self.parse_xvg(hist_file)
        # First column is the reaction coordinate; rest are per-window histograms
        positions = columns[0]
        histograms = np.column_stack(columns[1:])  # shape (n_bins, n_windows)
        n_windows = histograms.shape[1]

        overlaps: List[float] = []
        poorly_sampled: List[int] = []

        for i in range(n_windows - 1):
            h1 = histograms[:, i]
            h2 = histograms[:, i + 1]

            # Normalise to probability densities
            s1 = h1.sum()
            s2 = h2.sum()
            if s1 == 0 or s2 == 0:
                overlaps.append(0.0)
                poorly_sampled.append(i)
                continue

            p1 = h1 / s1
            p2 = h2 / s2
            # Overlap coefficient = sum of min(p1, p2)
            overlap = float(np.sum(np.minimum(p1, p2)))
            overlaps.append(overlap)
            if overlap < 0.10:
                poorly_sampled.append(i)

        min_ovl = min(overlaps) if overlaps else 0.0
        mean_ovl = float(np.mean(overlaps)) if overlaps else 0.0

        logger.info(f"Histogram overlap: min={min_ovl:.2%}, mean={mean_ovl:.2%}")
        if poorly_sampled:
            logger.warning(f"Poorly sampled window pairs (< 10% overlap): {poorly_sampled}")

        return {
            "n_windows": n_windows,
            "overlaps": overlaps,
            "min_overlap": min_ovl,
            "mean_overlap": mean_ovl,
            "poorly_sampled": poorly_sampled,
        }

    # ------------------------------------------------------------------
    # PMF profile analysis
    # ------------------------------------------------------------------

    def analyze_pmf_profile(self, pmf_file: Optional[str] = None) -> Dict:
        """Parse pmf.xvg and extract binding free energy and barriers.

        Parameters
        ----------
        pmf_file : str, optional
            Path to pmf.xvg.  Defaults to ``umbrella/pmf.xvg``.

        Returns
        -------
        dict
            ``distances``        – reaction coordinate array (nm)
            ``pmf_values``       – PMF values array (energy units from WHAM)
            ``binding_energy``   – depth of the PMF minimum relative to bulk
            ``min_pmf``          – minimum PMF value
            ``min_distance``     – distance at PMF minimum
            ``barrier_height``   – height of the largest barrier from the minimum
            ``barrier_distance`` – distance at barrier maximum
        """
        if pmf_file is None:
            pmf_file = str(self.umbrella_dir / "pmf.xvg")

        distances, pmf_values = self.parse_xvg(pmf_file)

        min_idx = int(np.argmin(pmf_values))
        min_pmf = float(pmf_values[min_idx])
        min_dist = float(distances[min_idx])

        # Binding energy: PMF at large distance (bulk) minus minimum
        # Use the last 10 % of the profile as a bulk estimate
        n_bulk = max(1, len(pmf_values) // 10)
        bulk_pmf = float(np.mean(pmf_values[-n_bulk:]))
        binding_energy = bulk_pmf - min_pmf

        # Barrier: maximum PMF between minimum and bulk
        if min_idx < len(pmf_values) - 1:
            post_min = pmf_values[min_idx:]
            barrier_idx_local = int(np.argmax(post_min))
            barrier_height = float(post_min[barrier_idx_local]) - min_pmf
            barrier_dist = float(distances[min_idx + barrier_idx_local])
        else:
            barrier_height = 0.0
            barrier_dist = min_dist

        logger.info(f"PMF minimum: {min_pmf:.2f} at {min_dist:.2f} nm")
        logger.info(f"Binding free energy: {binding_energy:.2f}")
        logger.info(f"Barrier height: {barrier_height:.2f} at {barrier_dist:.2f} nm")

        return {
            "distances": distances,
            "pmf_values": pmf_values,
            "binding_energy": binding_energy,
            "min_pmf": min_pmf,
            "min_distance": min_dist,
            "barrier_height": barrier_height,
            "barrier_distance": barrier_dist,
        }

    def analyze_convergence(self, n_blocks: int = 5) -> Dict:
        """Block averaging convergence analysis on umbrella pullf data.

        Splits each window's trajectory into *n_blocks* equal blocks,
        computes mean force per block, and reports the standard error
        as a proxy for convergence.

        Parameters
        ----------
        n_blocks : int
            Number of blocks for averaging.

        Returns
        -------
        dict
            ``n_blocks``          – number of blocks used
            ``window_means``      – per-window mean force across full trajectory
            ``window_block_stds`` – per-window std of block means
            ``converged``         – True if all block stds < 20% of overall std
        """
        validation = self.validate_umbrella_windows()
        if validation["completed_windows"] == 0:
            raise RuntimeError("No completed umbrella windows found for convergence analysis")

        window_dirs = sorted(self.umbrella_dir.glob("window_*"))

        means: List[float] = []
        block_stds: List[float] = []

        for wdir in sorted(window_dirs):
            pullf = wdir / "pullf.xvg"
            if not pullf.exists():
                continue
            try:
                _, forces = self.parse_xvg(str(pullf))
            except (ValueError, FileNotFoundError):
                continue

            full_mean = float(np.mean(forces))
            means.append(full_mean)

            # Split into blocks
            block_size = len(forces) // n_blocks
            if block_size < 2:
                block_stds.append(0.0)
                continue

            block_means = [
                float(np.mean(forces[i * block_size : (i + 1) * block_size]))
                for i in range(n_blocks)
            ]
            block_stds.append(float(np.std(block_means)))

        # Convergence criterion: all block stds < 20% of overall std
        overall_std = float(np.std(means)) if means else 0.0
        threshold = 0.20 * overall_std if overall_std > 0 else float("inf")
        converged = all(s < threshold for s in block_stds) if block_stds else False

        logger.info(
            f"Convergence analysis: {len(means)} windows, "
            f"{'converged' if converged else 'NOT converged'}"
        )

        return {
            "n_blocks": n_blocks,
            "window_means": means,
            "window_block_stds": block_stds,
            "converged": converged,
        }

    # ------------------------------------------------------------------
    # Plotting helpers
    # ------------------------------------------------------------------

    def plot_smd_force(self, output: Optional[str] = None) -> str:
        """Generate force vs position plot from SMD data.

        Parameters
        ----------
        output : str, optional
            Output image path.  Defaults to ``smd/smd_force.png``.

        Returns
        -------
        str
            Path to the saved figure.
        """
        try:
            import matplotlib
            matplotlib.use("Agg")
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError("matplotlib is required for plotting: pip install matplotlib")

        smd = self.analyze_smd()

        if output is None:
            output = str(self.smd_dir / "smd_force.png")

        fig, axes = plt.subplots(2, 1, figsize=(10, 8), sharex=False)

        # Force vs time
        ax = axes[0]
        ax.plot(smd["force_time"], smd["force_values"], linewidth=0.5, alpha=0.8)
        ax.axhline(y=0, color="gray", linestyle="--", linewidth=0.5)
        ax.axvline(x=smd["rupture_time"], color="red", linestyle="--", linewidth=0.8,
                   label=f"Rupture: {smd['rupture_force']:.0f} kJ/mol/nm")
        ax.set_xlabel("Time (ps)")
        ax.set_ylabel("Force (kJ/mol/nm)")
        ax.set_title("SMD Pull Force")
        ax.legend()

        # Position vs time
        ax = axes[1]
        ax.plot(smd["position_time"], smd["position_values"], linewidth=0.8)
        ax.set_xlabel("Time (ps)")
        ax.set_ylabel("COM Distance (nm)")
        ax.set_title("SMD Pull Position")

        fig.tight_layout()
        fig.savefig(output, dpi=150, bbox_inches="tight")
        plt.close(fig)

        logger.info(f"SMD force plot saved: {output}")
        return output

    def plot_pmf_profile(self, output: Optional[str] = None) -> str:
        """Generate PMF profile plot with energy landscape annotation.

        Parameters
        ----------
        output : str, optional
            Output image path.  Defaults to ``umbrella/pmf_profile.png``.

        Returns
        -------
        str
            Path to the saved figure.
        """
        try:
            import matplotlib
            matplotlib.use("Agg")
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError("matplotlib is required for plotting: pip install matplotlib")

        pmf = self.analyze_pmf_profile()

        if output is None:
            output = str(self.umbrella_dir / "pmf_profile.png")

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(pmf["distances"], pmf["pmf_values"], "b-", linewidth=1.5)
        ax.axhline(y=0, color="gray", linestyle="--", linewidth=0.5)

        # Annotate minimum
        ax.plot(pmf["min_distance"], pmf["min_pmf"], "rv", markersize=10,
                label=f"Min: {pmf['min_pmf']:.2f} at {pmf['min_distance']:.2f} nm")

        # Annotate barrier
        if pmf["barrier_height"] > 0:
            barrier_val = pmf["min_pmf"] + pmf["barrier_height"]
            ax.plot(pmf["barrier_distance"], barrier_val, "r^", markersize=10,
                    label=f"Barrier: {pmf['barrier_height']:.2f}")

        ax.set_xlabel("Distance (nm)")
        ax.set_ylabel("PMF")
        ax.set_title(f"PMF Profile (Binding Energy: {pmf['binding_energy']:.2f})")
        ax.legend()

        fig.tight_layout()
        fig.savefig(output, dpi=150, bbox_inches="tight")
        plt.close(fig)

        logger.info(f"PMF profile plot saved: {output}")
        return output

    def plot_histogram_overlap(self, output: Optional[str] = None) -> str:
        """Plot umbrella window histogram overlap.

        Parameters
        ----------
        output : str, optional
            Output image path.  Defaults to ``umbrella/histogram_overlap.png``.

        Returns
        -------
        str
            Path to the saved figure.
        """
        try:
            import matplotlib
            matplotlib.use("Agg")
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError("matplotlib is required for plotting: pip install matplotlib")

        hist_file = str(self.umbrella_dir / "histo.xvg")
        columns = self.parse_xvg(hist_file)
        positions = columns[0]
        histograms = np.column_stack(columns[1:])

        if output is None:
            output = str(self.umbrella_dir / "histogram_overlap.png")

        fig, ax = plt.subplots(figsize=(12, 6))
        for i in range(histograms.shape[1]):
            ax.plot(positions, histograms[:, i], linewidth=0.8, alpha=0.7)

        ax.set_xlabel("Reaction Coordinate (nm)")
        ax.set_ylabel("Count")
        ax.set_title(f"Umbrella Sampling Histograms ({histograms.shape[1]} windows)")

        fig.tight_layout()
        fig.savefig(output, dpi=150, bbox_inches="tight")
        plt.close(fig)

        logger.info(f"Histogram overlap plot saved: {output}")
        return output

    # ------------------------------------------------------------------
    # Report generation
    # ------------------------------------------------------------------

    def generate_report(self, output_dir: Optional[str] = None) -> str:
        """Generate a comprehensive PMF analysis text report.

        Runs all available analyses and writes a summary file.

        Parameters
        ----------
        output_dir : str, optional
            Directory for the report.  Defaults to *pmf_dir*.

        Returns
        -------
        str
            Path to the generated report file.
        """
        if output_dir is None:
            output_dir = str(self.pmf_dir)
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        report_path = output_dir / "pmf_analysis_report.txt"

        lines: List[str] = []
        lines.append("=" * 60)
        lines.append("PRISM PMF Analysis Report")
        lines.append("=" * 60)
        lines.append("")

        # --- SMD ---
        if self.smd_dir.exists() and (self.smd_dir / "pullf.xvg").exists():
            lines.append("--- Steered MD (SMD) Results ---")
            try:
                smd = self.analyze_smd()
                lines.append(f"  Rupture force : {smd['rupture_force']:.1f} kJ/mol/nm")
                lines.append(f"  Rupture time  : {smd['rupture_time']:.0f} ps")
                lines.append(f"  Rupture pos.  : {smd['rupture_position']:.3f} nm")
                lines.append(f"  Work (total)  : {smd['work']:.1f} kJ/mol")
            except Exception as exc:
                lines.append(f"  Error: {exc}")
            lines.append("")

        # --- Umbrella validation ---
        if self.umbrella_dir.exists():
            lines.append("--- Umbrella Sampling Validation ---")
            try:
                val = self.validate_umbrella_windows()
                lines.append(f"  Total windows     : {val['total_windows']}")
                lines.append(f"  Completed windows : {val['completed_windows']}")
                lines.append(f"  Completion rate   : {val['completion_rate']:.0%}")
                if val["failed_windows"]:
                    lines.append(f"  Failed windows    : {', '.join(val['failed_windows'])}")
            except Exception as exc:
                lines.append(f"  Error: {exc}")
            lines.append("")

        # --- Histogram overlap ---
        hist_file = self.umbrella_dir / "histo.xvg"
        if hist_file.exists():
            lines.append("--- Histogram Overlap ---")
            try:
                hist = self.check_histogram_overlap()
                lines.append(f"  Windows           : {hist['n_windows']}")
                lines.append(f"  Min overlap       : {hist['min_overlap']:.2%}")
                lines.append(f"  Mean overlap      : {hist['mean_overlap']:.2%}")
                if hist["poorly_sampled"]:
                    lines.append(f"  Poorly sampled    : pairs {hist['poorly_sampled']}")
            except Exception as exc:
                lines.append(f"  Error: {exc}")
            lines.append("")

        # --- PMF profile ---
        pmf_file = self.umbrella_dir / "pmf.xvg"
        if pmf_file.exists():
            lines.append("--- PMF Profile ---")
            try:
                pmf = self.analyze_pmf_profile()
                lines.append(f"  Binding energy    : {pmf['binding_energy']:.2f}")
                lines.append(f"  PMF minimum       : {pmf['min_pmf']:.2f} at {pmf['min_distance']:.2f} nm")
                lines.append(f"  Barrier height    : {pmf['barrier_height']:.2f} at {pmf['barrier_distance']:.2f} nm")
            except Exception as exc:
                lines.append(f"  Error: {exc}")
            lines.append("")

        # --- Convergence ---
        if self.umbrella_dir.exists():
            lines.append("--- Convergence Analysis ---")
            try:
                conv = self.analyze_convergence()
                status = "CONVERGED" if conv["converged"] else "NOT CONVERGED"
                lines.append(f"  Status            : {status}")
                lines.append(f"  Blocks            : {conv['n_blocks']}")
                lines.append(f"  Windows analyzed  : {len(conv['window_means'])}")
            except Exception as exc:
                lines.append(f"  Error: {exc}")
            lines.append("")

        lines.append("=" * 60)

        report = "\n".join(lines)
        with open(report_path, "w") as fh:
            fh.write(report)

        logger.info(f"Analysis report saved: {report_path}")
        return str(report_path)
